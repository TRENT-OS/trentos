name: CI Tests OdroidC2 Hardware

on:
  workflow_dispatch:
  workflow_call:

permissions:
  contents: read

concurrency:
  group: ci-odroidc2-hw
  #cancel-in-progress: true # Do we want this? this would cause current tests to be stopped if a new ci request is launched.
  # Waiting till the current run is done is probably the better solution

env:
  BUILD_PLAT: "odroidc2"
  TEST_PLAT: "odroidc2-ci"
  PLAT_IP: "192.168.88.109"
  GATEWAY_IP: "192.168.88.2"
  RUNNER_IP: "192.168.88.2" # TODO: Implement this not static

jobs:
  #check_label:
  #  runs-on: ubuntu-latest
  #  steps:
  #    - name: Check if label is applied
  #      id: label-check
  #      run: |
  #        if [[ $(jq -r '.action' "$GITHUB_EVENT_PATH") == "labeled" && $(jq -r '.label.name' "$GITHUB_EVENT_PATH") == "Run-CI" ]]; then
  #          echo "Label 'Run-CI' applied. Running workflow steps."
  #        else
  #          echo "Label 'Run-CI' not applied. Exiting workflow without running steps."
  #          exit 78  # Exit with a neutral status to mark the check as pending
  #        fi
  #    - name: Checkout repository
  #      uses: actions/checkout@v2

  # THIS IS A DUMMY DO NOT USE IN PRODUCTION!!!
  check_label:
    runs-on: ubuntu-latest
    outputs:
      BUILD_PLAT: ${{ env.BUILD_PLAT }}
      TEST_PLAT: ${{ env.TEST_PLAT }}
      PLAT_IP: ${{ env.PLAT_IP }}
      GATEWAY_IP: ${{ env.GATEWAY_IP }}
      RUNNER_IP: ${{ env.RUNNER_IP }}
  
    steps:
      - name: Dummy
        id: label-check
        run: echo "dummy"

  # tested: reliable
  demo_hello_world:
    needs: check_label
    uses: FelixSchladt/sandbox/.github/workflows/demo_hello_world_hw.yml@main
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  demo_vm_minimal:
    needs: [demo_hello_world, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: FelixSchladt/sandbox/.github/workflows/demo_vm_minimal.yml@main
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  demo_vm_virtio_net:
    needs: [demo_vm_minimal, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: FelixSchladt/sandbox/.github/workflows/demo_vm_virtio_net.yml@main
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  demo_vm_serialserver:
    needs: [demo_vm_virtio_net, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: FelixSchladt/sandbox/.github/workflows/demo_vm_serialserver.yml@main
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: reliable
  test_certparser:
    needs: [demo_vm_serialserver, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: FelixSchladt/sandbox/.github/workflows/test_certparser_hw.yml@main
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: fails (log output is messed up and strings cant be found. Test runs fine)
  # reason: Test fails du to multiple components simulatnously writing on the output uart.
  # the different messages interrupt each other and the string matchin doesnt work because of this.
  #test_certserver:
  #  needs: test_certparser
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: FelixSchladt/sandbox/.github/workflows/test_certserver_hw.yml@main
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  #tested: fails (test completes fine, but output seems to be messed up)
  # test takes forever to fail
  #test_config_server:
  #  needs: test_certserver
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: FelixSchladt/sandbox/.github/workflows/test_config_server_hw.yml@main
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  #tested: unreliable (most tests pass, a random few dont(amount and which tests is random))
  # in most cases some random tests fail due to inability to find success log string
  # test_crypto_api:
  #   needs: [test_certparser, check_label]
  #   if: ${{ always() && needs.check_label.result == 'success' }}
  #   uses: FelixSchladt/sandbox/.github/workflows/test_crypto_api_hw.yml@main
  #   with:
  #     BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #     TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # #tested: reliable
  # test_cryptoserver:
  #   needs: [test_crypto_api, check_label]
  #   if: ${{ always() && needs.check_label.result == 'success' }}
  #   uses: FelixSchladt/sandbox/.github/workflows/test_cryptoserver_hw.yml@main
  #   with:
  #     BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #     TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # # tested: reliable
  # test_entropysource:
  #   needs: [test_cryptoserver, check_label]
  #   if: ${{ always() && needs.check_label.result == 'success' }}
  #   uses: FelixSchladt/sandbox/.github/workflows/test_entropysource_hw.yml@main
  #   with:
  #     BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #     TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # # tested: reliable
  # test_filesystem:
  #   needs: [test_entropysource, check_label]
  #   if: ${{ always() && needs.check_label.result == 'success' }}
  #   uses: FelixSchladt/sandbox/.github/workflows/test_filesystem_hw.yml@main
  #   with:
  #     BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #     TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # # tested: reliable
  # test_keystore:
  #   needs: [test_filesystem, check_label]
  #   if: ${{ always() && needs.check_label.result == 'success' }}
  #   uses: FelixSchladt/sandbox/.github/workflows/test_keystore_hw.yml@main
  #   with:
  #     BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #     TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: fails
  # seems like some strings are not found
  # some match statements seem to fail these look a bit strange
  #test_logserver:
  #  needs: test_keystore
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: FelixSchladt/sandbox/.github/workflows/test_logserver_hw.yml@main
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: fails
  # normal log rambling as well as some non supported stuff such as chanmux tests, needs more digging
  #test_storage_interface:
  #  needs: test_logserver
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: FelixSchladt/sandbox/.github/workflows/test_storage_interface_hw.yml@main
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: reliable
  # test_timeserver:
  #   needs: [test_keystore, check_label] # run test consecutively as only on test at a time can be performed on hardware
  #   if: ${{ always() && needs.check_label.result == 'success' }}
  #   uses: FelixSchladt/sandbox/.github/workflows/test_timeserver_hw.yml@main
  #   with:
  #     BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #     TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: DOES NOT COMPILE DUE TO NOT MERGED PICOTCP-NG (this is an setup issue of my seos-tests)
  #test_tls_api:
  #  needs: test_timeserver
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: FelixSchladt/sandbox/.github/workflows/test_tls_api_hw.yml@main
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: DOES NOT COMPILE DUE TO NOT MERGED PICOTCP-NG (this is an setup issue of my seos-tests)
  #test_tlsserver:
  #  needs: test_tls_api
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: FelixSchladt/sandbox/.github/workflows/test_tlsserver_hw.yml@main
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  #
  # TODO: TEST UART -> I am not sure how this should be implemented and if this is something we will do
  # The odroid uart implementation seems to still have some issues and bugs with the uart driver.
  # This should be fixed in a  future release.
