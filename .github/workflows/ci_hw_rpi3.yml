name: CI Tests RPI3 Hardware

on:
  workflow_dispatch:
  workflow_call:

permissions:
  contents: read

concurrency:
  group: ci-rpi3-hw
  #cancel-in-progress: true # Do we want this? this would cause current tests to be stopped if a new ci request is launched.
  # Waiting till the current run is done is probably the better solution

env:
  BUILD_PLAT: "rpi3"
  TEST_PLAT: "rpi3-ci"
  PLAT_IP: "10.178.169.40"
  GATEWAY_IP: "10.178.169.33"
  RUNNER_IP: "10.70.192.3" # TODO: Implement this not static

jobs:
  #check_label:
  #  runs-on: ubuntu-latest
  #  steps:
  #    - name: Check if label is applied
  #      id: label-check
  #      run: |
  #        if [[ $(jq -r '.action' "$GITHUB_EVENT_PATH") == "labeled" && $(jq -r '.label.name' "$GITHUB_EVENT_PATH") == "Run-CI" ]]; then
  #          echo "Label 'Run-CI' applied. Running workflow steps."
  #        else
  #          echo "Label 'Run-CI' not applied. Exiting workflow without running steps."
  #          exit 78  # Exit with a neutral status to mark the check as pending
  #        fi
  #    - name: Checkout repository
  #      uses: actions/checkout@v2

  # THIS IS A DUMMY DO NOT USE IN PRODUCTION!!!
  check_label:
    runs-on: ubuntu-latest
    outputs:
      BUILD_PLAT: ${{ env.BUILD_PLAT }}
      TEST_PLAT: ${{ env.TEST_PLAT }}
      PLAT_IP: ${{ env.PLAT_IP }}
      GATEWAY_IP: ${{ env.GATEWAY_IP }}
      RUNNER_IP: ${{ env.RUNNER_IP }}
  
    steps:
      - name: Dummy
        id: label-check
        run: echo "dummy"

  # tested: reliable
  demo_hello_world:
    needs: check_label #THIS MUST BE ENABLED IN PRODUCTION USE
    uses: TRENT-OS/trentos/.github/workflows/demo_hello_world_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: reliable
  test_certparser:
    needs: [demo_hello_world, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: TRENT-OS/trentos/.github/workflows/test_certparser_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: fails (log output is messed up and strings cant be found. Test runs fine)
  # reason: Test fails du to multiple components simulatnously writing on the output uart.
  # the different messages interrupt each other and the string matchin doesnt work because of this.
  #test_certserver:
  #  needs: test_certparser
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: TRENT-OS/trentos/.github/workflows/test_certserver_hw.yml@actions-hw-ci
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  #tested: fails (test completes fine, but output seems to be messed up)
  # test takes forever to fail
  #test_config_server:
  #  needs: test_certserver
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: TRENT-OS/trentos/.github/workflows/test_config_server_hw.yml@actions-hw-ci
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  #tested: unreliable (most tests pass, a random few dont(amount and which tests is random))
  # in most cases some random tests fail due to inability to find success log string
  test_crypto_api:
    needs: [test_certparser, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: TRENT-OS/trentos/.github/workflows/test_crypto_api_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  #tested: reliable
  test_cryptoserver:
    needs: [test_crypto_api, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: TRENT-OS/trentos/.github/workflows/test_cryptoserver_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: reliable
  test_entropysource:
    needs: [test_cryptoserver, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: TRENT-OS/trentos/.github/workflows/test_entropysource_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: reliable
  test_filesystem:
    needs: [test_entropysource, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: TRENT-OS/trentos/.github/workflows/test_filesystem_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: reliable
  test_keystore:
    needs: [test_filesystem, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: TRENT-OS/trentos/.github/workflows/test_keystore_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: failsnvidia
  # seems like some strings are not found
  # some match statements seem to fail these look a bit strange
  #test_logserver:
  #  needs: test_keystore
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: TRENT-OS/trentos/.github/workflows/test_logserver_hw.yml@actions-hw-ci
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}
  
   #tested: ? THIS NEEDS WORK and probably needs to be split into multiple tests
   # tested: tcp_server: unreliable Most tests pass, 3 consistently fail - these are disabled for now should be investigated after switch to picotcp-ng
  test_network_api:
    needs: [test_keystore, check_label]
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: TRENT-OS/trentos/.github/workflows/test_network_api_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}
      PLAT_IP: ${{ needs.check_label.outputs.PLAT_IP }}
      GATEWAY_IP: ${{ needs.check_label.outputs.GATEWAY_IP }}
      RUNNER_IP: ${{ needs.check_label.outputs.RUNNER_IP }}

  # tested: fails
  # normal log rambling as well as some non supported stuff such as chanmux tests, needs more digging
  #test_storage_interface:
  #  needs: test_logserver
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: TRENT-OS/trentos/.github/workflows/test_storage_interface_hw.yml@actions-hw-ci
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: reliable
  test_timeserver:
    needs: [test_network_api, check_label] # run test consecutively as only on test at a time can be performed on hardware
    if: ${{ always() && needs.check_label.result == 'success' }}
    uses: TRENT-OS/trentos/.github/workflows/test_timeserver_hw.yml@actions-hw-ci
    with:
      BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
      TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: DOES NOT COMPILE DUE TO NOT MERGED PICOTCP-NG (this is an setup issue of my seos-tests)
  #test_tls_api:
  #  needs: test_timeserver
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: TRENT-OS/trentos/.github/workflows/test_tls_api_hw.yml@actions-hw-ci
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}

  # tested: DOES NOT COMPILE DUE TO NOT MERGED PICOTCP-NG (this is an setup issue of my seos-tests)
  #test_tlsserver:
  #  needs: test_tls_api
  #  if: ${{ always() && needs.check_label.result == 'success' }}
  #  uses: TRENT-OS/trentos/.github/workflows/test_tlsserver_hw.yml@actions-hw-ci
  #  with:
  #    BUILD_PLAT: ${{ needs.check_label.outputs.BUILD_PLAT }}
  #    TEST_PLAT: ${{ needs.check_label.outputs.TEST_PLAT }}


  #
  # TEST UART -> I am not sure how this should be implemented and if this is something we will do
  #
