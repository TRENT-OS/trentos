def TEST_SYSTEM = 'test_network_api'
def BUILD_SPEC  = 'build-zynq7000-Debug-' + TEST_SYSTEM

// bind the localtime to docker container to avoid problems of gaps between the
// localtime of the container and the host.
// add to group "stack" in order to grant usage of Haskell stack in the docker
// image

def DOCKER_BUILD_ENV = [ image: 'docker:5000/seos_build_env:latest',
                         args: ' -v /etc/localtime:/etc/localtime:ro '+
                               ' --group-add=1001',
                         registry: 'http://docker:5000'
                       ]

def DOCKER_TEST_ENV  = [ image: 'docker:5000/seos_test_env:latest',
                         args:  ' -v /home/jenkins/.ssh/:/home/jenkins/.ssh:ro'+
                                ' -v /etc/localtime:/etc/localtime:ro' +
                                ' --network=host' +
                                ' --cap-add=NET_ADMIN' +
                                ' --cap-add=NET_RAW' +
                                ' --device=/dev/net/tun',
                         registry: 'http://docker:5000'
                       ]

def agent_builderLabel = "build"

def agent_testerLabel  = "test"

def agent_testerLabel_specialized  = "test_network"

// Channels and users to notify on Slack with the build result.
//
// notify_channels = "#channel_name @USV2L0ACX @USV2L0ACX @USV2L0ACX"
//
//             posts to the slack channel and to the 3 users as private message
// @USV2L0ACX is a slack member ID, you can copy yours from your slack profile.
def notify_success = ""
def notify_failure = "#jenkins"

def print_step_info(name) { echo "#################### " + name }

pipeline {
    agent none
    options {
        skipDefaultCheckout true
    }
    stages {
        stage('Build_stage'){
            agent { label agent_builderLabel }
            stages {
                stage('clean_checkout') {
                    steps {
                        print_step_info env.STAGE_NAME
                        cleanWs()
                        // everything is in separate folders to avoid file conflicts. Sources are checked out into
                        // "scm-src", builds should generate "build-xxx" folders, tests will use "workspace_test" ...
                        dir('scm-src') {
                            checkout scm
                            // Notify Bitbucket that job is in progress
                            step([$class: 'StashNotifier'])
                        }
                    }
                }
                stage('build') {
                    agent {
                        docker {
                            reuseNode true
                            alwaysPull true
                            registryUrl DOCKER_BUILD_ENV.registry
                            image DOCKER_BUILD_ENV.image
                            args DOCKER_BUILD_ENV.args
                        }
                    }
                    steps {
                        print_step_info env.STAGE_NAME
                        // trigger the build
                        sh 'scm-src/build.sh ' + TEST_SYSTEM
                        stash name: 'build_stash', includes: '**'
                    }
                }
                stage('astyle_check') {
                    steps {
                        print_step_info env.STAGE_NAME
                        catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
                            sh 'scm-src/build.sh check_astyle_artifacts'
                        }
                        sh 'rm -rf *'
                    }
                }
            }
        }
        stage('prepare_test') {
            agent {
                docker {
                    label agent_testerLabel
                    alwaysPull true
                    reuseNode true
                    registryUrl DOCKER_TEST_ENV.registry
                    image DOCKER_TEST_ENV.image
                    args DOCKER_TEST_ENV.args
                }
            }
            steps {
                print_step_info env.STAGE_NAME
                sh 'rm -rf *'
                unstash 'build_stash'
                sh 'scm-src/test.sh prepare'
                stash name: 'test_env_stash', includes: 'scm-src/**, workspace_test/**,' + BUILD_SPEC + '/**'
                sh 'rm -rf *'
            }
        }
        stage('test') {
            agent {
                docker {
                    label agent_testerLabel_specialized
                    alwaysPull true
                    reuseNode true
                    registryUrl DOCKER_TEST_ENV.registry
                    image DOCKER_TEST_ENV.image
                    args DOCKER_TEST_ENV.args
                }
            }
            steps {
                print_step_info env.STAGE_NAME
                sh 'rm -rf *'
                unstash 'test_env_stash'
                catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
                    lock('nw_test_lock'){
                        sh 'scm-src/test.sh run ' + TEST_SYSTEM + '.py'
                    }
                }
                junit 'test-logs-*/test_results.xml'
                stash name: 'test_result_stash', includes: ' test-logs*/**,' + BUILD_SPEC + '/**'
                sh 'rm -rf *'
            }
        }
    }
    post {
        always {
            node(agent_testerLabel)
            {
                print_step_info 'archive artifacts'
                sh 'rm -rf *'
                unstash 'test_result_stash'
                sh 'tar -cjf '+BUILD_SPEC+'.bz2 '+BUILD_SPEC+'/ test-logs-*/'
                archiveArtifacts artifacts: BUILD_SPEC + '.bz2', fingerprint: true
                sh 'rm -rf *'
                // Notify Bitbucket that job is done
                step([$class: 'StashNotifier'])
            }
        }
        success {
            // Notify slack that build succeded
            slackSend color: 'good', channel : notify_success, message: \
            "${currentBuild.currentResult} : `${env.JOB_NAME}` #${env.BUILD_NUMBER}"
        }
        failure {
            // Notify slack that build failed
            slackSend color: 'bad', channel : notify_failure, message: \
            "${currentBuild.currentResult} : `${env.JOB_NAME}` #${env.BUILD_NUMBER}"
        }
        unstable {
            // Notify slack that build is unstable
            slackSend color: 'bad', channel : notify_failure, message: \
            "${currentBuild.currentResult} : `${env.JOB_NAME}` #${env.BUILD_NUMBER}"
        }
    }
}
