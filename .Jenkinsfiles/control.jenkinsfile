//------------------------------------------------------------------------------
//
// Generic Jenkins Pipeline Control Script
//
// Copyright (C) 2019, Hensoldt Cyber GmbH
//
//-------------------------------------------------------------------------------


//------------------------------------------------------------------------------
properties([
    buildDiscarder( logRotator( numToKeepStr: '20' ) )
])


//------------------------------------------------------------------------------
// Test system list
class TestCtx {
    String      systemName;  // Name of the system to build.
    String      testScript;  // Test script to be executed. Defaults to
                             // <systemName>.py.
    ArrayList   platforms;   // List of supported platforms. `null` if full
                             // support.

    public TestCtx(
        String systemName,
        String testScript,
        ArrayList platforms)
    {
        this.systemName  = systemName;
        this.testScript  = testScript;
        this.platforms   = platforms;
    }
}

def ACTIVE_TESTS = [

    new TestCtx('demo_hello_world',              'test_demo_hello_world.py',      null),
//    new TestCtx('demo_iot_app',                  'test_demo_iot_app.py',          null),
//    new TestCtx('demo_iot_app_rpi3',             'test_demo_iot_app.py',          ['rpi3']),
//    new TestCtx('demo_iot_app_imx6',             'test_demo_iot_app.py',          ['sabre']),
//    new TestCtx('test_timeserver',               null,                            null),
//    new TestCtx('test_uart',                     null,                            null),
//    new TestCtx('test_chanmux',                  null,                            null),
//    new TestCtx('test_proxy_nvm',                null,                            null),
//    new TestCtx('test_certparser',               'test_certparser.py',            null),
//    new TestCtx('test_crypto_api',               null,                            null),
//    new TestCtx('test_cryptoserver',             null,                            null),
//    new TestCtx('test_entropysource',            null,                            null),
//    new TestCtx('test_storage_interface',        null,                            null),
//    new TestCtx('test_filesystem',               null,                            null),
//    new TestCtx('test_config_server',            null,                            null),
//    new TestCtx('test_keystore',                 null,                            null),
//    new TestCtx('test_logserver',                null,                            null),
//    new TestCtx('test_network_api',              null,                            null),
//    new TestCtx('test_tls_api',                  null,                            null),
//    new TestCtx('test_secure_update',            null,                            null),
//    new TestCtx('test_tlsserver',                null,                            null)

    // ToDo: create test scripts
    // ['native_hello_world',            null,                        null],
    // ['native_sel4test',               null,                        null],

]

//------------------------------------------------------------------------------
// Test Platforms
def PLATFORMS = [
    'zynq7000',
    'sabre',
    // 'migv',
    // 'spike',
    // 'rpi3',
]


//------------------------------------------------------------------------------
def get_job_package_name(platform, test_system)
{
    return 'package-' + platform + '-' + test_system
}


//------------------------------------------------------------------------------
def get_build_relative_url(build)
{
    // getAbsoluteUrl() is deprecate and generally regarded as a bad idea for
    // generating HTML page content. This workaround avoids accessing the raw
    // build, which can't be done by scripts by default

    return '/job/' +
            build.getFullProjectName().replace("/", "/job/") +
            '/' +
            build.getNumber()

}


//------------------------------------------------------------------------------
def get_result_ball_img_url(result)
{
    def states = [
        'SUCCESS':  'green.gif', // there is no png
        'UNSTABLE': 'yellow.png',
        'FAILURE':  'red.png',
        'ABORTED':  'aborted.png'
    ]

    return Jenkins.RESOURCE_PATH +
            '/images/16x16/' +
            states.get(result, 'help.png')
}


//------------------------------------------------------------------------------

def execute_build(global_ctx, test_ctx, branch, platform)
{
    def run_job = '../' + test_ctx.systemName + '/' + branch

    // starting the build with wait=true will make the call block until the
    // build has finished
    // https://dev.to/pencillr/jenkins-pipelines-and-their-dirty-secrets-3

    def jobBuild = build(
                        job: 'generic_jobs/generic_pipeline',
                        wait: true,
                        parameters: [
                            string(name: 'BRANCH_OR_COMMIT',   value: branch),
                            string(name: 'JENKINSFILE',        value: '.Jenkinsfiles/generic.jenkinsfile'),
                            string(name: 'TEST_SYSTEM',        value: test_ctx.systemName),
                            string(name: 'TEST_SCRIPT',        value: test_ctx.testScript ?: ''),
                            string(name: 'PLATFORM',           value: platform ?: ''),
                        ]
                   )

    // if we arrive here, the job has finished

    def pkg_name = get_job_package_name(platform, test_ctx.systemName)
    global_ctx.builds[pkg_name] = jobBuild

    def result = jobBuild.getResult()

    println test_ctx.systemName + ' took ' + jobBuild.getDuration() +' ms, result: ' + result

    global_ctx.summary.appendText(
        platform + ', ' + test_ctx.systemName + ':' +
        ' <a href="' + get_build_relative_url(jobBuild) + '">' +
            '#' + jobBuild.getNumber() +
        '</a>' +
        ' <img src="' + get_result_ball_img_url(result) + '">' +
        '<br>',
        false)

    node {
        cleanWs()

        catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE')
        {
            def artifact_name = 'package.bz2'
            copyArtifacts(
                filter: artifact_name,
                projectName: jobBuild.getFullProjectName(),
                selector: specific("${jobBuild.getNumber()}") // need to ensure this is a string
            )

            sh 'mv ' + artifact_name + ' ' + pkg_name + '.bz2'
            stash name: pkg_name, includes: '**'
        }

        cleanWs()
    }
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
def global_ctx = [
    stashCnt: 0,
    summary: manager.createSummary("orange-square.png"),
    builds: [:],
    buildStages: [:],
]

// if we use a loop "for (test_ctx in ACTIVE_TESTS) ..." there is an issue
// with the closure, since only one instance of the loop variable "test_ctx"
// exists. Effectively all closures will only see the value that "test_ctx"
// had for the last iteration. When using the loop as
//     ACTIVE_TESTS.each { test_ctx -> ...
// we can void this nicely, since the closure is created for each loop and thus
// there is one dedicated instance of "test_ctx" that the inner closure will
// use

ACTIVE_TESTS.each { test_ctx ->
    def test_system = test_ctx.systemName

    PLATFORMS.each { platform ->
        def pkg_name = get_job_package_name(platform, test_system)

        def filter = test_ctx.platforms
        if(filter == null || filter.any{ it == platform} ){
            global_ctx.buildStages[pkg_name] = {
                stage(pkg_name) {
                    execute_build(
                        global_ctx,
                        test_ctx,
                        env.BRANCH_NAME,
                        platform)
                }
            }
        }
    }
}

// start the build and wait until all finish. We don't need to take en executor
// here for this.
catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE')
{
    parallel global_ctx.buildStages
}

// builds are done, collect results. Now we need to run somewhere and have a
// workspace, thus we take do things in a node
node {
    stage('process_results')
    {
        cleanWs()

        global_ctx.builds.each { pkg_name, jobBuild ->

            catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE')
            {
                unstash pkg_name // put <pkg_name>.bz2 into workspace
                sh 'mkdir ' + pkg_name
                sh 'tar -xf ' + pkg_name + '.bz2 -C ' + pkg_name + '/'
                sh 'rm ' + pkg_name + '.bz2'
            }
        }

        // ToDo: support multiple platforms here, currently this would see the
        //       same test case for each platform and it's likely messing up
        //       the analysis
        junit 'package-*/test-logs/test_results.xml'

        sh 'tar -cjf package.bz2 package-*/'
        archiveArtifacts artifacts: 'package.bz2', fingerprint: true
    }
}
