//------------------------------------------------------------------------------
//
// Generic Jenkins Pipeline Control Script
//
// Copyright (C) 2019, Hensoldt Cyber GmbH
//
//-------------------------------------------------------------------------------


//------------------------------------------------------------------------------
properties([
    buildDiscarder( logRotator( numToKeepStr: '20' ) )
])


//------------------------------------------------------------------------------
// Test system list
//
// Elements:
//   <SYSTEM_NAME>:  system name
//   <TEST_MACHINE>: defaults to 'test'
//   <TEST_SCRTIPT>: defaults to <SYSTEM_NAME>.py
//
def ACTIVE_TESTS = [

    ['demo_hello_world',              null,                'test_demo_hello_world.py'],
    ['demo_iot_app',                  'test_in_isolation', 'test_demo_iot_app.py'],
    ['demo_iot_app_rpi3',             'test_in_isolation', 'test_demo_iot_app_rpi3.py'],
    ['test_chanmux',                  null,                null],
    ['test_proxy_nvm',                null,                null],
    ['test_cert_lib',                 null,                null],
    ['test_crypto_api',               null,                null],
    ['test_cryptoserver',             null,                null],
    ['test_entropysource',            null,                null],
    ['test_partition_manager',        null,                null],
    // ['test_seos_filestream',          null,                null], // broken build:
    ['test_filesystem_as_lib',        null,                null],
    ['test_filesystem',               null,                null],
    ['test_config_server_fs_backend', null,                null],
    ['test_config_server',            null,                null],
    ['test_keystore',                 null,                null],
    ['test_logserver',                null,                null],
    ['test_network_api',              'test_network',      null],
    ['test_tls_api',                  'test_tls',          null],
    ['test_tlsserver',                'test_tls',          null],
    ['test_storage_interface',        null,                null],
]

//------------------------------------------------------------------------------
// Test Platforms
//
// ToDo: building for multiple platforms works fine, but testing is currently
//       no implemented, as we have the zynq7000 QEMU hard coded. Furthermore,
//       the junit test result processor step in Jenkins need to be adopted to
//       support multiple platforms.

def PLATFORMS = [
    'zynq7000',
    // 'imx6',
    // 'migv',
    // 'spike',
    // 'rpi3',
]


//------------------------------------------------------------------------------
def get_job_package_name(platform, test_system)
{
    return 'package-' + platform + '-' + test_system
}


//------------------------------------------------------------------------------
def get_build_relative_url(build)
{
    // getAbsoluteUrl() is deprecate and generally regarded as a bad idea for
    // generating HTML page content. This workaround avoids accessing the raw
    // build, which can't be done by scripts by default

    return '/job/' +
            build.getFullProjectName().replace("/", "/job/") +
            '/' +
            build.getNumber()

}


//------------------------------------------------------------------------------
def get_result_ball_img_url(result)
{
    def states = [
        'SUCCESS':  'green.gif', // there is no png
        'UNSTABLE': 'yellow.png',
        'FAILURE':  'red.png',
        'ABORTED':  'aborted.png'
    ]

    return Jenkins.RESOURCE_PATH +
            '/images/16x16/' +
            states.get(result, 'help.png')
}


//------------------------------------------------------------------------------

def execute_build(global_ctx, test_ctx, branch, platform)
{
    def test_system = test_ctx[0]
    def test_machine_label = test_ctx[1]
    def test_script = test_ctx[2]

    def run_job = '../' + test_system + '/' + branch

    // starting the build with wait=true will make the call block until the
    // build has finished
    // https://dev.to/pencillr/jenkins-pipelines-and-their-dirty-secrets-3

    def jobBuild = build(
                        job: 'generic_jobs/generic_pipeline',
                        wait: true,
                        parameters: [
                            string(name: 'BRANCH_OR_COMMIT',   value: branch),
                            string(name: 'JENKINSFILE',        value: '.Jenkinsfiles/generic.jenkinsfile'),
                            string(name: 'TEST_SYSTEM',        value: test_system),
                            string(name: 'TEST_MACHINE_LABEL', value: test_machine_label ?: ''),
                            string(name: 'TEST_SCRIPT',        value: test_script ?: ''),
                            string(name: 'PLATFORM',           value: platform ?: ''),
                        ]
                   )

    // if we arrive here, the job has finished

    def pkg_name = get_job_package_name(platform, test_system)
    global_ctx.builds[pkg_name] = jobBuild

    def result = jobBuild.getResult()

    println test_system + ' took ' + jobBuild.getDuration() +' ms, result: ' + result

    global_ctx.summary.appendText(
        platform + ', ' + test_system + ':' +
        ' <a href="' + get_build_relative_url(jobBuild) + '">' +
            '#' + jobBuild.getNumber() +
        '</a>' +
        ' <img src="' + get_result_ball_img_url(result) + '">' +
        '<br>',
        false)

    node {
        cleanWs()

        catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE')
        {
            def artifact_name = 'package.bz2'
            copyArtifacts(
                filter: artifact_name,
                projectName: jobBuild.getFullProjectName(),
                selector: specific("${jobBuild.getNumber()}") // need to ensure this is a string
            )

            sh 'mv ' + artifact_name + ' ' + pkg_name + '.bz2'
            stash name: pkg_name, includes: '**'
        }

        cleanWs()
    }
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
def global_ctx = [
    stashCnt: 0,
    summary: manager.createSummary("orange-square.png"),
    builds: [:],
    buildStages: [:],
]

// if we use a loop "for (test_ctx in ACTIVE_TESTS) ..." there is an issue
// with the closure, since only one instance of the loop variable "test_ctx"
// exists. Effectively all closures will only see the value that "test_ctx"
// had for the last iteration. When using the loop as
//     ACTIVE_TESTS.each { test_ctx -> ...
// we can void this nicely, since the closure is created for each loop and thus
// there is one dedicated instance of "test_ctx" that the inner closure will
// use

ACTIVE_TESTS.each { test_ctx ->
    def test_system = test_ctx[0]

    PLATFORMS.each { platform ->
        def pkg_name = get_job_package_name(platform, test_system)
        global_ctx.buildStages[pkg_name] = {
            stage(pkg_name) {
                execute_build(global_ctx, test_ctx, env.BRANCH_NAME, platform)
            }
        }
    }
}

// start the build and wait until all finish. We don't need to take en executor
// here for this.
catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE')
{
    parallel global_ctx.buildStages
}

// builds are done, collect results. Now we need to run somewhere and have a
// workspace, thus we take do things in a node
node {
    stage('process_results')
    {
        cleanWs()

        global_ctx.builds.each { pkg_name, jobBuild ->

            catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE')
            {
                unstash pkg_name // put <pkg_name>.bz2 into workspace
                sh 'mkdir ' + pkg_name
                sh 'tar -xf ' + pkg_name + '.bz2 -C ' + pkg_name + '/'
                sh 'rm ' + pkg_name + '.bz2'
            }
        }

        // ToDo: support multiple platforms here, currently this would see the
        //       same test case for each platform and it's likely messing up
        //       the analysis
        junit 'package-*/test-logs/test_results.xml'

        sh 'tar -cjf package.bz2 package-*/'
        archiveArtifacts artifacts: 'package.bz2', fingerprint: true
    }
}
